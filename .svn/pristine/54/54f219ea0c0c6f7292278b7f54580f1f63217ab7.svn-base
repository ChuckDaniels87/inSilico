//[prevTut]{
#include <iostream>
#include <fstream>
#include <string>
#include <boost/lexical_cast.hpp>
#include <base/shape.hpp>
#include <base/Unstructured.hpp>
#include <base/io/smf/Reader.hpp>
//[prevTut]}

#include <base/fe/Basis.hpp>
#include <base/Field.hpp>
#include <base/dof/numbering.hpp>
#include <base/dof/generate.hpp>
#include <base/io/Format.hpp>

STATIC_ASSERT_MSG( (FUNDEG==1) or (FUNDEG==2) or (FUNDEG==3),
                   "Choice of polynomial degree not allowed" );

//------------------------------------------------------------------------------
int main( int argc, char * argv[] )
{
    // Check the number of input arguments
    if ( argc != 2 ) { 
        std::cout << "Usage:  " << argv[0] << " file.smf \n";
        return 0;
    }
    
    const unsigned    geomDeg  = 1;
    const unsigned    fieldDeg = FUNDEG;
    const base::Shape shape    = base::QUAD;

    // number of components per degree of freedom
    const unsigned    doFSize = 1;

    //--------------------------------------------------------------------------
    typedef base::Unstructured<shape,geomDeg>     Mesh;

    // Read mesh from file
    Mesh mesh;
    {
        const std::string smfFile = boost::lexical_cast<std::string>( argv[1] );
        std::ifstream smf( smfFile.c_str() );
        base::io::smf::readMesh( smf, mesh );
        smf.close();
    }

    // FE Basis
    typedef base::fe::Basis<shape,fieldDeg> FEBasis;

    // Field interpolation
    typedef base::Field<FEBasis,doFSize>           Field;
    Field field;

    // sparsity pattern (debug only)
    std::size_t nnz = 0;
    std::size_t nnzPerRow = 0;
    {

        base::dof::IndexMap<FEBasis> indexMap;
        base::dof::generateAndPreserveIndexMap<FEBasis>( mesh, field, indexMap );
        
        std::vector< std::vector<std::size_t> > sparsity;
        indexMap.generateSparsityPattern( sparsity );

        const std::string spName =
            "sparsity." + base::io::leadingZeros( fieldDeg, 1 ) + ".dat";

        std::ofstream sp( spName.c_str() );
        sp << "# Sparsity pattern generated by " << argv[0]
           << "  " << argv[1] << '\n'
           << "# Geometry degree = " << geomDeg
           << ",  Field degree = " << fieldDeg << '\n';
        for ( unsigned d1 = 0; d1 < sparsity.size(); d1 ++ ) {
            for ( unsigned d2 = 0; d2 < sparsity[d1].size(); d2++ ) {
                sp << d1 << " " << sparsity[d1][d2] << "\n";
                nnz ++;
            }
            nnzPerRow = std::max( sparsity[d1].size(), nnzPerRow );
        }
        sp.close();
    }

    // compute number of dofs
    const std::size_t numDoFs = 
        base::dof::numberDoFsConsecutively( field.doFsBegin(),
                                            field.doFsEnd() );

    // do a few calculations
    const double spRatio = ( static_cast<double>( nnz ) /
                             static_cast<double>( numDoFs * numDoFs ) );

    const std::string numNonZeros = base::io::formatWithLocale( nnz );
    const std::string numDegOFree = base::io::formatWithLocale( numDoFs );
    
    std::cout << "Number of dofs:                 " << numDegOFree << '\n'
              << "Maximal number of dofs per row: " << nnzPerRow << '\n'
              << "Number of non-zero entries:     " << numNonZeros << '\n'
              << "Sparsity:                       " << spRatio     << '\n'
              << "    (= " << numNonZeros << "/" << numDegOFree << "*" << numDegOFree
              << " = " << numNonZeros  << "/"
              << base::io::formatWithLocale( numDoFs * numDoFs )
              << ") \n";

    return 0;
}
