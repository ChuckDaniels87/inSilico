//------------------------------------------------------------------------------
// <preamble>
// </preamble>
//------------------------------------------------------------------------------

//! @file   unitCubeSMF.cpp
//! @author Thomas Rueberg
//! @date   2013

#include <tools/meshGeneration/unitCube/unitCube.hpp>

//------------------------------------------------------------------------------
/** Generate an equi-distant mesh on a unit hypercube.
 *  The user provides the number of elements per direction (the number of these
 *  numbers implies the dimension) and this tool writes the generated mesh in
 *  SMF format to stdout.
 */
int main( int argc, char* argv[] )
{
    namespace unitCube = tools::meshGeneration::unitCube;
    
    unsigned dim, n1, n2, n3, e1, e2, e3;
    unitCube::userInput( argc, argv, dim, n1, n2, n3, e1, e2, e3 );
    

    //--------------------------------------------------------------------------
    // Header with message
    std::cout << "# Generated by nCube, input: ";
    for ( int i = 0; i < argc; i ++ ) std::cout << argv[i] << " ";
    std::cout << "\n"
              << "! elementShape "
              << ( dim == 1 ? "line" : ( dim == 2 ? "quadrilateral" :
                                         "hexahedron" ) ) << "\n"
              << "! elementNumPoints "
              << ( dim == 1 ? 2 : ( dim == 2 ? 4 : 8 ) ) << "\n";

    // total number of nodes and elements
    const unsigned numNodes = n1 * n2 * n3;
    const unsigned numElems = e1 * e2 * e3;
    std::cout << numNodes << "  " << numElems << "\n";

    unitCube::writeNodes( n1, n2, n3, e1, e2, e3, std::cout );

    //--------------------------------------------------------------------------
    // connectivity
    for ( unsigned i3 = 0; i3 < e3; i3++ ) {
        for ( unsigned i2 = 0; i2 < e2; i2++ ) {
            for ( unsigned i1 = 0; i1 < e1; i1++ ) {

                // serilialise index
                const unsigned i = i1 +
                    (dim > 1 ? i2 * n1      : 0) +
                    (dim > 2 ? i3 * n2 * n2 : 0 );

                // line element
                std::cout << i << " " << i + 1;

                // extend to quad
                if ( dim > 1 ) {
                    std::cout << " " << n1 + i + 1 << " " << n1 + i;
                }

                // extend to hex
                if ( dim > 2 ) {
                    std::cout << " " << (n1*n2) + i << " " << (n1*n2) + i + 1
                              << " " << (n1*n2) + n1 + i + 1
                              << " " << (n1*n2) + n1 + i;
                }

                std::cout << "\n";

            }
        }
    }
                

    return 0;
}
