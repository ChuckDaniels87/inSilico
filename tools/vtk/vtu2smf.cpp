#include <vtkSmartPointer.h>
#include <vtkXMLUnstructuredGridReader.h>
#include <vtkXMLUnstructuredGridWriter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkPointData.h>
#include <vtkCellData.h>
#include <vtkIdList.h>
//------------------------------------------------------------------------------
#include <string>
#include <iostream>
#include <vector>
#include <cassert>
#include <sstream>

namespace tools{
    namespace vtk{

        std::string elementName( const unsigned vtkNum )
        {
            switch( vtkNum ) {
                case 3:  // LIN2
                case 21: // LIN3
                    return "line"; break;
                case 22: // TRI6
                case  5: // TRI3
                    return "triangle"; break;
                case 9:  // QUAD4
                    return "quadrilateral"; break;
                case 10: // TET4
                case 24: // TET10
                    return "tetrahedron"; break;
                case 12: // HEX8
                    return "hexahedron"; break;
                default: return "UNDEFINED";
            }
            return "UNDEFINED";
        }

        // number of nodes  per element
        unsigned numNodesPerElement( const unsigned vtkNum )
        {
            switch( vtkNum ) {
                case  3: return  2; break;
                case 21: return  3; break;
                case 22: return  6; break;
                case  5: return  3; break;
                case  9: return  4; break;
                case 10: return  4; break;
                case 24: return 10; break;
                case 12: return  8; break;
                default: return  0; 
            }
            return 0;
        }

        // number of sub-elements per element (quadratic elements are partitioned)
        unsigned numElementsPerCell( const unsigned vtkNum )
        {
            switch( vtkNum ) {
                case 22 : 
                case 23 : return 4; break;
                default : return 1; break;
            }
            return 0;
        }
    }
}

//------------------------------------------------------------------------------
int main(int argc, char *argv[])
{
    //parse command line arguments
    if( argc != 2 ) {
        std::cerr << "Usage: " << argv[0]
                  << " filename.vtu" << std::endl;
        return EXIT_FAILURE;
    }
 
    // file names
    const std::string filename = argv[1];
    const std::string basename = filename.substr( 0, filename.find( ".vtu" ) );
    const std::string smfOut   = basename + ".smf";
 
    //read XML vtu file
    vtkSmartPointer<vtkXMLUnstructuredGridReader> reader =
        vtkSmartPointer<vtkXMLUnstructuredGridReader>::New();
    reader -> SetFileName( filename.c_str() );
    reader -> Update();

    // get access to the unstructured grid
    vtkSmartPointer<vtkUnstructuredGrid> unstructuredGrid = reader -> GetOutput();

    // get header data
    const unsigned numPoints   = unstructuredGrid -> GetNumberOfPoints();
    const unsigned cellType    = unstructuredGrid -> GetCellType( 0 );
    const unsigned numCells    = unstructuredGrid -> GetNumberOfCells();
    const unsigned numSubElem  = tools::vtk::numElementsPerCell( cellType );
    const unsigned numElements = numCells * numSubElem;

    // access to points
    vtkSmartPointer<vtkPoints> points = unstructuredGrid -> GetPoints();

    // open data stream
    std::ofstream smf( smfOut.c_str() );

    // write header
    smf << "# Generated by vtu2smf" << std::endl;

    smf << "! elementShape "     << tools::vtk::elementName( cellType ) << std::endl;
    smf << "! elementNumPoints " << tools::vtk::numNodesPerElement( cellType ) << std::endl;
    smf << " " << numPoints << " " << numCells << std::endl;
    
    // write coordinates
    for ( unsigned np = 0; np < numPoints; np ++ ) {
        // coordinates
        double xyz[3];
        points -> GetPoint( np, xyz );
        smf << xyz[0] << " "  << xyz[1] << " " << xyz[2] << std::endl;
    }
    
    // write connectivity
    for ( unsigned c = 0; c < numCells; c ++ ) {
        assert( unstructuredGrid -> GetCellType( c ) == cellType );
        const unsigned num = tools::vtk::numNodesPerElement( cellType );
        vtkSmartPointer<vtkIdList> idList = vtkSmartPointer<vtkIdList>::New();
        idList -> SetNumberOfIds( num );
        unstructuredGrid -> GetCellPoints( c, idList );
        for ( unsigned p = 0; p < num; p ++ ) {
            smf << idList -> GetId( p )  << "  ";
        }
        smf << std::endl;
    }
    smf.close();

    return EXIT_SUCCESS;
}

 
