//------------------------------------------------------------------------------
// <preamble>
// </preamble>
//------------------------------------------------------------------------------

//! @file   smfRotate.cpp
//! @author Thomas Rueberg
//! @date   2013

//------------------------------------------------------------------------------
// std includes
#include <iostream>
#include <fstream>
#include <string>
// boost includes
#include <boost/lexical_cast.hpp>
// base includes
#include <base/verify.hpp>
#include <base/linearAlgebra.hpp>
// tools includes
#include <tools/converter/smf2xx/SMFHeader.hpp>
#include <tools/converter/smf2xx/Conversion.hpp>
// local includes
#include <tools/converter/smfAffine/smfAffine.hpp>


//------------------------------------------------------------------------------
/** Read smf formatted file, create a temporary mesh and write smf data file
 */
int main( int argc, char * argv[] )
{
    namespace smfAffine = tools::converter::smfAffine;
    namespace smf2xx    = tools::converter::smf2xx;
    
    // Sanity check of the number of input arguments
    if ( argc != 2 ) {
        std::cout << "Usage:  " << argv[0]
                  << " file.smf \n\n";
        return 0;
    }

    std::cout << "------------------------------------------\n"
              << "**  Rotation y = R(alpha,u) * (x - x_0) **\n"
              << "------------------------------------------\n";

    // Name of smf input file, its basename and the data output file name
    const std::string smfFileIn  = boost::lexical_cast<std::string>( argv[1] );
    const std::string base       = smfFileIn.substr(0, smfFileIn.find( ".smf") );
    const std::string smfFileOut  = base + ".rot.smf";

    // Element attributes
    base::Shape elementShape;
    unsigned    elementNumPoints;
    
    {
        // extract data from header
        std::ifstream smf( smfFileIn.c_str() );
        smf2xx::readSMFHeader( smf, elementShape, elementNumPoints );
        smf.close();
    }

    // User input of transformation matrix and vector
    {
        // Axis of rotation
        smfAffine::Vec axis;
        axis[0] = 0.; axis[1] = 0.; axis[2] = 1.;

        std::cout << "* Enter coefficients of the rotation axis u:\n";
        for ( unsigned i = 0; i < 3; i++ ) {

            const double deflt = static_cast<double>( i == 2 );
            std::cout << "    u(" << i << ") "
                      << "[default: " << deflt << "]  = ";

            std::string aux;
            std::getline( std::cin, aux );
            if ( aux.length() > 0 )
                axis[i] = boost::lexical_cast<double>( aux );
        }

        // centre of rotation
        smfAffine::Vec centre;
        centre[0] = 0.; centre[1] = 0.; centre[2] = 0.;

        std::cout << "* Enter coefficients of the rotation centre x_0:\n";
        for ( unsigned i = 0; i < 3; i++ ) {

            const double deflt = 0.;
            std::cout << "    x_0(" << i << ") "
                      << "[default: " << deflt << "]  = ";

            std::string aux;
            std::getline( std::cin, aux );
            if ( aux.length() > 0 )
                centre[i] = boost::lexical_cast<double>( aux );
        }

        // normalise the axis
        axis /= base::norm( axis );


        // Angle of rotation
        double alpha = 0.;

        std::cout << "* Enter angle of rotation (in degrees): \n"
                  << "  alpha = ";
        std::cin  >> alpha;

        // convert to radiant
        alpha *= (M_PI / 180.);

        // compute 3D rotation matrix from axis and angle
        // a la Rodrigues 
        // http://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
        {
            smfAffine::Mat uu = axis * (axis.transpose());
            smfAffine::Mat ux;
            ux( 0, 0 ) =       0.; ux( 0, 1 ) = -axis[2]; ux( 0, 2 ) =  axis[1];
            ux( 1, 0 ) =  axis[2]; ux( 1, 1 ) =       0.; ux( 1, 2 ) = -axis[0];
            ux( 2, 0 ) = -axis[1]; ux( 2, 1 ) =  axis[0]; ux( 2, 2 ) =       0.;

            smfAffine::A = std::sin( alpha ) * ux + (1. - std::cos(alpha) ) * uu;
            for ( unsigned d = 0; d < 3; d++ )
                smfAffine::A( d, d ) += std::cos( alpha );

            smfAffine::c = - smfAffine::A * centre;
        }
        
        
        std::cout << "* Entered the affine transformation \n "
                  << " A = \n" << smfAffine::A << "\n"
                  << " c = " << smfAffine::c.transpose() << "\n";

    }

    // Input and output file streams
    std::ifstream smfIn(   smfFileIn.c_str() );
    std::ofstream smfOut( smfFileOut.c_str() );

    // write to file for traceback
    smfOut << "# Generated by smfRotate \n";

    // Call generic conversion helper
    smf2xx::Conversion< smfAffine::Converter >::apply( elementShape,
                                                       elementNumPoints,
                                                       smfIn, smfOut );

    // Close the streams
    smfIn.close();
    smfOut.close();
    
    return 0;
}
