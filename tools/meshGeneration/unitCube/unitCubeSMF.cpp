//------------------------------------------------------------------------------
// <preamble>
// </preamble>
//------------------------------------------------------------------------------

//! @file   unitCubeSMF.cpp
//! @author Thomas Rueberg
//! @date   2013

// std includes
#include <iostream>
#include <vector>
// tools includes
#include <tools/meshGeneration/meshGeneration.hpp>
#include <tools/meshGeneration/unitCube/unitCube.hpp>

//------------------------------------------------------------------------------
/** Generate an equi-distant mesh on a unit hypercube.
 *  The user provides the number of elements per direction (the number of these
 *  numbers implies the dimension) and this tool writes the generated mesh in
 *  SMF format to stdout.
 */
int main( int argc, char* argv[] )
{
    namespace unitCube = tools::meshGeneration::unitCube;
    
    unsigned dim, n1, n2, n3, e1, e2, e3;
    const bool input = 
        unitCube::userInput( argc, argv, dim, n1, n2, n3, e1, e2, e3 );
    if ( not input ) return 0;
    

    //--------------------------------------------------------------------------
    // Header with message
    std::cout << "# Generated by nCube, input: ";
    for ( int i = 0; i < argc; i ++ ) std::cout << argv[i] << " ";
    std::cout << "\n";

    const std::string elementShape = ( dim == 1 ? "line" :
                                       ( dim == 2 ? "quadrilateral" :
                                         "hexahedron" ) );
    const unsigned elementNumPoints = ( dim == 1 ? 2 : ( dim == 2 ? 4 : 8 ) );
    const unsigned numNodes = n1 * n2 * n3;
    const unsigned numElems = e1 * e2 * e3;

    tools::meshGeneration::writeSMFHeader( elementShape, elementNumPoints,
                                           numNodes, numElems, std::cout );

    //--------------------------------------------------------------------------
    // Points
    std::vector<tools::meshGeneration::Point> points;
    unitCube::generatePoints( n1, n2, n3, e1, e2, e3, points );
    tools::meshGeneration::writePoints( points, std::cout );

    //--------------------------------------------------------------------------
    // connectivity
    std::vector<tools::meshGeneration::Element> elements;
    
    for ( unsigned i3 = 0; i3 < e3; i3++ ) {
        for ( unsigned i2 = 0; i2 < e2; i2++ ) {
            for ( unsigned i1 = 0; i1 < e1; i1++ ) {

                tools::meshGeneration::Element element;
                
                // serialise index
                const unsigned i = i1 +
                    (dim > 1 ? i2 * n1      : 0) +
                    (dim > 2 ? i3 * n2 * n2 : 0 );

                // line element
                element.push_back( i );
                element.push_back( i + 1 );

                // extend to quad
                if ( dim > 1 ) {
                    element.push_back( n1 + i + 1 );
                    element.push_back( n1 + i     );
                }

                // extend to hex
                if ( dim > 2 ) {
                    element.push_back( (n1*n2)      + i     );
                    element.push_back( (n1*n2)      + i + 1 );
                    element.push_back( (n1*n2) + n1 + i + 1 );
                    element.push_back( (n1*n2) + n1 + i     );
                }

                elements.push_back( element );
            }
        }
    }

    // write to stream
    tools::meshGeneration::writeElements( elements, std::cout );
                

    return 0;
}
