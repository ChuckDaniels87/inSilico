//------------------------------------------------------------------------------
// <preamble>
// </preamble>
//------------------------------------------------------------------------------

//! @file   unitCubeSMF.cpp
//! @author Thomas Rueberg
//! @date   2013

// std includes
#include <iostream>
#include <vector>
// base includes
#include <base/cut/DecomposeHyperCube.hpp>
#include <base/mesh/HierarchicOrder.hpp>
// tools includes
#include <tools/meshGeneration/meshGeneration.hpp>
#include <tools/meshGeneration/unitCube/unitCube.hpp>

//------------------------------------------------------------------------------
namespace{

    //--------------------------------------------------------------------------
    //! Make mesh of simplex elements in cube
    template<unsigned DIM>
    struct TriangulateCube
    {
        typedef base::cut::DecomposeHyperCube<DIM> DHC;
        
        static void apply( const tools::meshGeneration::Element& cube,
                           std::vector<tools::meshGeneration::Element>& elements )
        {
            for ( unsigned s = 0; s < DHC::numSimplices; s++ ) {
                tools::meshGeneration::Element simplex;
                for ( unsigned v = 0; v < DIM+1; v++ ) {
                    const std::size_t index = DHC::apply( s, v );
                    simplex.push_back( cube[index] );
                } 
                elements.push_back( simplex );
            }
            return;
        }
    };

    //--------------------------------------------------------------------------
    //! Generate hierarchic element from tensor-product ordering
    template<unsigned DIM>
    struct HierarchicCube
    {
        typedef base::mesh::HierarchicOrder<base::HyperCubeShape<DIM>::value,1>
        HO;

        static const unsigned numVertices = base::MToTheN<2,DIM>::value;
        
        static void apply( const tools::meshGeneration::Element& cube,
                           std::vector<tools::meshGeneration::Element>& elements )
        {
            tools::meshGeneration::Element orderedCube;
            for ( unsigned v = 0; v < numVertices; v++ ) {
                orderedCube.push_back( cube[ HO::apply( v ) ] );
            }
            elements.push_back( orderedCube );
            
            return;
        }
    };
    
}

//------------------------------------------------------------------------------
/** Generate an equi-distant mesh on a unit hypercube.
 *  The user provides the number of elements per direction (the number of these
 *  numbers implies the dimension) and this tool writes the generated mesh in
 *  SMF format to stdout.
 */
int main( int argc, char* argv[] )
{
#ifdef SIMPLEX
    const bool makeSimplices = true;
#else
    const bool makeSimplices = false;
#endif
    
    namespace unitCube = tools::meshGeneration::unitCube;
    
    unsigned dim, n1, n2, n3, e1, e2, e3;
    const bool input = 
        unitCube::userInput( argc, argv, dim, n1, n2, n3, e1, e2, e3 );
    if ( not input ) return 0;
    

    //--------------------------------------------------------------------------
    // Header with message
    std::cout << "# Generated by unitCubeSMF (compiled for "
              << ( makeSimplices ? "simplices" : "hypercubes" )
              << ") input: ";
    for ( int i = 0; i < argc; i ++ ) std::cout << argv[i] << " ";
    std::cout << "\n";

    // element shape
    const std::string cubeShape =
        ( dim == 1 ? "line" : ( dim == 2 ? "quadrilateral" : "hexahedron" ) );
    const std::string simplexShape =
        ( dim == 1 ? "line" : ( dim == 2 ? "triangle"      : "tetrahedron" ) );
    const std::string elementShape = ( makeSimplices ? simplexShape : cubeShape );
    
    // number of points per element
    const unsigned numCubePoints    = dim * dim - dim + 2;
    const unsigned numSimplexPoints = dim + 1;
    const unsigned elementNumPoints = ( makeSimplices ? numSimplexPoints : numCubePoints );

    // total number of nodes and elements
    const unsigned numNodes = n1 * n2 * n3;
    const unsigned numSimplicesPerCube = ( dim == 3 ? 6 : dim );
    const unsigned numElems = e1 * e2 * e3 * (makeSimplices ? numSimplicesPerCube : 1);

    tools::meshGeneration::writeSMFHeader( elementShape, elementNumPoints,
                                           numNodes, numElems, std::cout );

    //--------------------------------------------------------------------------
    // Points
    std::vector<tools::meshGeneration::Point> points;
    unitCube::generatePoints( n1, n2, n3, e1, e2, e3, points );
    tools::meshGeneration::writePoints( points, std::cout );

    //--------------------------------------------------------------------------
    // connectivity
    std::vector<tools::meshGeneration::Element> elements;
    
    for ( unsigned i3 = 0; i3 < e3; i3++ ) {
        for ( unsigned i2 = 0; i2 < e2; i2++ ) {
            for ( unsigned i1 = 0; i1 < e1; i1++ ) {

                tools::meshGeneration::Element cube;
                
                // serialise index
                const unsigned i = i1 +
                    (dim > 1 ? i2 * n1      : 0) +
                    (dim > 2 ? i3 * n2 * n2 : 0 );

                // line element
                cube.push_back( i );
                cube.push_back( i + 1 );

                // extend to quad
                if ( dim > 1 ) {
                    cube.push_back( n1 + i     );
                    cube.push_back( n1 + i + 1 );
                }

                // extend to hex
                if ( dim > 2 ) {
                    cube.push_back( (n1*n2)      + i     );
                    cube.push_back( (n1*n2)      + i + 1 );
                    cube.push_back( (n1*n2) + n1 + i     );
                    cube.push_back( (n1*n2) + n1 + i + 1 );
                }

                // generate elements
                if ( dim == 1 ) {
                    if ( makeSimplices ) TriangulateCube<1>::apply( cube, elements );
                    else                 HierarchicCube<1>::apply(  cube, elements );
                }
                else if ( dim == 2 ) {
                    if ( makeSimplices ) TriangulateCube<2>::apply( cube, elements );
                    else                 HierarchicCube<2>::apply(  cube, elements );
                }
                else {
                    if ( makeSimplices ) TriangulateCube<3>::apply( cube, elements );
                    else                 HierarchicCube<3>::apply(  cube, elements );
                }
                    
            }
        }
    }

    // write to stream
    tools::meshGeneration::writeElements( elements, std::cout );
                

    return 0;
}
