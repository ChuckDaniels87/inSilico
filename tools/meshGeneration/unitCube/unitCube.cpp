//------------------------------------------------------------------------------
// <preamble>
// </preamble>
//------------------------------------------------------------------------------

//! @file   unitCube.cpp
//! @author Thomas Rueberg
//! @date   2013

// std includes
#include <iostream>
// boost includes
#include <boost/lexical_cast.hpp>


//------------------------------------------------------------------------------
/** Generate an equi-distant mesh on a unit hypercube.
 *  The user provides the number of elements per direction (the number of these
 *  numbers implies the dimension) and this tool writes the generated mesh in
 *  SMF format to stdout.
 */
int main( int argc, char* argv[] )
{
    // Usage message
    if ( (argc < 2) or (argc > 4) ) {
        std::cout << "Usage:  " << argv[0]
                  << " N1  [N2  [N3] ]\n";
        return -1;
    }

    // Induced spatial dimension
    const unsigned dim = boost::lexical_cast<unsigned>( argc-1 );

    // number of elements per direction
    const unsigned e1 =          boost::lexical_cast<unsigned>( argv[1] );
    const unsigned e2 = (dim>1 ? boost::lexical_cast<unsigned>( argv[2] ) : 1);
    const unsigned e3 = (dim>2 ? boost::lexical_cast<unsigned>( argv[3] ) : 1);

    // number of points per direction
    const unsigned n1 = e1+1;
    const unsigned n2 = (dim > 1 ? e2 + 1 : 1);
    const unsigned n3 = (dim > 2 ? e3 + 1 : 1);

    //--------------------------------------------------------------------------
    // Header with message
    std::cout << "# Generated by nCube, input: ";
    for ( int i = 0; i < argc; i ++ ) std::cout << argv[i] << " ";
    std::cout << "\n"
              << "! elementShape "
              << ( dim == 1 ? "line" : ( dim == 2 ? "quadrilateral" :
                                         "hexahedron" ) ) << "\n"
              << "! elementNumPoints "
              << ( dim == 1 ? 2 : ( dim == 2 ? 4 : 8 ) ) << "\n";

    // total number of nodes and elements
    const unsigned numNodes = n1 * n2 * n3;
    const unsigned numElems = e1 * e2 * e3;
    std::cout << numNodes << "  " << numElems << "\n";

    // spacing
    const double h1 = 1.0 / static_cast<double>( e1 );
    const double h2 = 1.0 / static_cast<double>( e2 );
    const double h3 = 1.0 / static_cast<double>( e3 );

        //--------------------------------------------------------------------------
    // node coordinates
    for ( unsigned i3 = 0; i3 < n3; i3++ ) {
        for ( unsigned i2 = 0; i2 < n2; i2++ ) {
            for ( unsigned i1 = 0; i1 < n1; i1++ ) {

                const double x = h1 * i1;
                const double y = h2 * i2;
                const double z = h3 * i3;

                std::cout << x << " " << y << " " << z << "\n";
            }
        }
    }

    //--------------------------------------------------------------------------
    // connectivity
    for ( unsigned i3 = 0; i3 < e3; i3++ ) {
        for ( unsigned i2 = 0; i2 < e2; i2++ ) {
            for ( unsigned i1 = 0; i1 < e1; i1++ ) {

                // serilialise index
                const unsigned i = i1 +
                    (dim > 1 ? i2 * n1      : 0) +
                    (dim > 2 ? i3 * n2 * n2 : 0 );

                // line element
                std::cout << i << " " << i + 1;

                // extend to quad
                if ( dim > 1 ) {
                    std::cout << " " << n1 + i + 1 << " " << n1 + i;
                }

                // extend to hex
                if ( dim > 2 ) {
                    std::cout << " " << (n1*n2) + i << " " << (n1*n2) + i + 1
                              << " " << (n1*n2) + n1 + i + 1
                              << " " << (n1*n2) + n1 + i;
                }

                std::cout << "\n";

            }
        }
    }
                

    return 0;
}
