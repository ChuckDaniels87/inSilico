//[prevTut]{
#include <iostream>
#include <fstream>
#include <string>
#include <boost/lexical_cast.hpp>
#include <base/mesh/Node.hpp>
#include <base/mesh/Element.hpp>
#include <base/mesh/Unstructured.hpp>
#include <base/LagrangeShapeFun.hpp>
#include <base/io/smf/Reader.hpp>
//[prevTut]}


#include <base/fe/Basis.hpp>
#include <base/dof/DegreeOfFreedom.hpp>
#include <base/dof/Element.hpp>
#include <base/dof/Field.hpp>
#include <base/dof/numbering.hpp>
#include <base/dof/generate.hpp>
#include <base/io/Format.hpp>

//------------------------------------------------------------------------------
int main( int argc, char * argv[] )
{
    // Check the number of input arguments
    if ( argc != 2 ) { 
        std::cout << "Usage:  " << argv[0] << " file.smf \n";
        return 0;
    }
    
    
    const unsigned    geomDeg  = 1;
    const unsigned    fieldDeg = 2;
    const base::Shape shape    = base::QUAD;

    // number of components per degree of freedom
    const unsigned    doFSize = 1;

    //--------------------------------------------------------------------------
    const unsigned    dim     = base::ShapeDim<shape>::value;
    typedef base::mesh::Node<dim>                 Node;
    typedef base::LagrangeShapeFun<geomDeg,shape> SFun;
    typedef base::mesh::Element<Node,SFun>        Element;
    typedef base::mesh::Unstructured<Element>     Mesh;

    // Read mesh from file
    Mesh mesh;
    {
        const std::string smfFile = boost::lexical_cast<std::string>( argv[1] );
        std::ifstream smf( smfFile.c_str() );
        base::io::smf::Reader<Mesh> smfReader;
        smfReader( mesh, smf ); 
        smf.close();
    }

    // FE Basis
    typedef base::fe::Basis<shape,fieldDeg> FEBasis;

    // Field interpolation
    typedef base::dof::DegreeOfFreedom<doFSize>    DoF;
    typedef base::dof::Element<DoF,FEBasis::FEFun> FieldElement;
    typedef base::dof::Field<FieldElement>         Field;
    Field field;


    
    // sparsity pattern (debug only)
    unsigned nnz = 0;
    unsigned nnzPerRow = 0;
    {

        base::dof::IndexMap<FEBasis> indexMap;
        base::dof::generateAndPreserveIndexMap<FEBasis>( mesh, field, indexMap );
        
        std::vector< std::vector<std::size_t> > sparsity;
        indexMap.generateSparsityPattern( sparsity );

        std::ofstream sp( "sparsity.dat" );
        sp << "# Sparsity pattern generated by " << argv[0]
           << "  " << argv[1] << '\n'
           << "# Geometry degree = " << geomDeg
           << ",  Field degree = " << fieldDeg << '\n';
        for ( unsigned d1 = 0; d1 < sparsity.size(); d1 ++ ) {
            for ( unsigned d2 = 0; d2 < sparsity[d1].size(); d2++ ) {
                sp << d1 << " " << sparsity[d1][d2] << "\n";
                nnz ++;
            }
            nnzPerRow = std::max( sparsity[d1].size(), nnzPerRow );
        }
        sp.close();
    }

    // compute number of dofs
    const std::size_t numDoFs = 
        base::dof::numberDoFsConsecutively( field.doFsBegin(),
                                            field.doFsEnd() );

    // do a few calculations
    const double spRatio = ( static_cast<double>( nnz ) /
                             static_cast<double>( numDoFs * numDoFs ) );

    const std::string numNonZeros = base::io::formatWithLocale( nnz );
    const std::string numDegOFree = base::io::formatWithLocale( numDoFs );
    
    std::cout << "Number of dofs:                 " << numDegOFree << '\n'
              << "Maximal number of dofs per row: " << nnzPerRow << '\n'
              << "Number of non-zero entries:     " << numNonZeros << '\n'
              << "Sparsity:                       " << spRatio     << '\n'
              << "    (= " << numNonZeros << "/" << numDegOFree << "*" << numDegOFree
              << " = " << numNonZeros  << "/"
              << base::io::formatWithLocale( numDoFs * numDoFs )
              << ") \n";

    return 0;
}
