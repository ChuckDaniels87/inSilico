\definecolor{gray97}{gray}{.97}
\definecolor{gray65}{gray}{.65}
\definecolor{gray20}{gray}{.20}
\definecolor{gray30}{gray}{.30}

\lstset{
    language=C++,
    basicstyle=\ttfamily\tiny\color{gray20},
    frame=Ltb,
    breakatwhitespace=false,         
  	breaklines=true,
	showspaces=false,                
	showstringspaces=false,          
	showtabs=false,
	tabsize=2,
	%	
	framerule=0pt,
    aboveskip=0.5cm,
    framextopmargin=3pt,
    framexbottommargin=3pt,
    framexleftmargin=0.4cm,
    framesep=0pt,
    rulesep=.4pt,
    backgroundcolor=\color{gray97},
    rulesepcolor=\color{black},                     
	%
	stringstyle=\ttfamily\tiny\textit,
    showstringspaces = false,
    commentstyle=\color{gray65},
    keywordstyle=\bfseries\color{black},
	%	
	numbers=left,
    numbersep=15pt,
    numberstyle=\tiny,
    numberfirstline = false,
	%	
	literate=
	{µ}{{$\mu$}}1 	{·}{{$\cdot$}}1
	{º}{{$\phantom{a}^{\circ}$}}1
	{²}{{$\phantom{a}^2$}}1
 	}



\IS{} is a software \emph{library}, that means it is designed to serve
as a code development platform. It is \emph{not} a FEM solver package,
like \texttt{ABAQUS}. If you want to use \IS, you need to program an
application code yourself.\\
\\
\IS{} is programmed in \texttt{C++} and makes heavily use of
\emph{templates}. In order to get an idea of templates, consider the
example given in figure~\ref{fig:template}. It shows two possible
template-based ways to implement the computation of the maximum of two
numbers. The important feature is that neither the class nor the
function knows of which specific type~\texttt{T} is. Therefore, they can
be employed in the software for any data type that allows the
\emph{less than} comparison based on the \texttt{operator$<$}.

\begin{figure}[htbp]
  \centering
\begin{lstlisting}
template<typename T> 
struct Max {
  static T apply(const T& a, const T& b)
  { 
    return (a > b? a : b );
  }
};
//usage (Note: explicit instantiation)
const double maximum = Max<double>::apply( 3.1, -1.2 );

template<typename T>
T max(const T& a, const T& b)
{
  return (a > b? a : b);
}
//usage (Note: argument dependent look-up)
const int    maxInt = max( 3,   -1   );
const double maxDob = max( 3.1, -1.2 );
\end{lstlisting}

  \caption{A template class (top) and a template function (bottom) for
  the computation of the maximum of two numbers; usage examples are given.}
  \label{fig:template}
\end{figure}

This seemingly simple example hints at the power hidden behind the
concept of template-based programming: properly designed code
units have to be defined only once for a certain task.  In the
example in the bottom of figure~\ref{fig:template} the function is
used for two different number types without the need of writing a
max-function for \texttt{int} and \texttt{double} separately.  Two
important remarks have to be made at this point:
\begin{itemize}
\item The second version looks neater, since the user only has to call
  that function and the type of~\texttt{T} is implicitly determined by
  the argument types of function. This concept is called
  \emph{argument dependent look-up}. Note that it fails if the types
  cannot be uniquely determined from the argument types.
\item Compilers are usually not very good in reporting a compilation
  error in a template-based code. Try compiling the example code for a
  complex number type (no $<$-comparison available) and enjoy the
  lengthy output.
\end{itemize}

Another potential of templates is the use of parameters instead of
types, which, for instance, is commonly used for fixed-size arrays. An
illustrative example is the template-based meta-programming as shown
in figure~\ref{fig:meta}. Here, the factorial of a number~$n$ is
computed. Note that the factorial has two possible definitions which
obviously give the same result,
\begin{equation*}
  n! = \prod_{i=1}^n i = 1 \times 2 \times \dots \times n 
  \qquad \text{or} \qquad
  n! = n (n-1)!\,, \quad 0! = 1\,.
\end{equation*}
Note that the standard way (top of figure~\ref{fig:meta}) exactly
reflects the first definition of the factorial. The second, recursive
definition is represented by the meta-program (bottom of the figure).
The advantage of this way is that the compiler will compute the
factorial and effectively write its result into the compiled
program. Thereby no run-time is consumed for this computation. 
It has to be emphasised that
\begin{itemize}
\item The value of the parameter of a template has to be known at
  compile time. In the example, it is not possible to compute~$n!$
  if~$n$ is a value that is asked from the user of the program.
\end{itemize}

\begin{figure}[htbp]
  \centering
  \begin{lstlisting}
unsigned factorial( const unsigned n ) 
{
  unsigned result = 1;
  for ( unsigned i = 2; i <= n; i++) result *= i;
  return result;
}

const unsigned facN = factorial( N ); //usage

template<unsigned N> struct Factorial // recursive template
{
  static const unsigned value = N * Factorial<N-1>::value;
};

template<> struct Factorial<0> // recursion stop
{
  static const unsigned value = 1;
};

//usage:
const unsigned facN = Factorial<N>::value; //N is known at compile-time
\end{lstlisting}

  \caption{Traditional way (top) and meta-program (bottom) to compute the factorial.}
  \label{fig:meta}
\end{figure}

The library \IS{} uses these concepts whenever possible. Consider for
example the node class as displayed in figure~\ref{fig:node}. The
class itself depends on the spatial dimension \texttt{DIM} which
determines the size of the coordinate the node holds. The exact type
used for that coordinate, defined elsewhere in the library, shall not
matter. Since the spatial dimension of the physical problem is
something that is known at the beginning and does not change in the
computation, it is an ideal candidate for a template
parameter. Moreover, the class holds two template functions for the
change and the access of the coordinate. Basically, the components of
the coordinate are copied from or to an iterator which goes over some
storage specified by the caller. This could refer to an array or
something more complicated, but does not affect the design of the node
class due to the template functions.

\begin{figure}[htbp]
  \centering
 \begin{lstlisting}
template<unsigned DIM>
class Node
{
public:
    //! Template parameter: spatial dimension
    static const unsigned dim = DIM;

    //! Coordinate type definition
    typedef typename base::Vector<dim>::Type VecDim;

    //! Constructor
    Node()
        : id_( base::invalidInt ),
          x_(  base::invalidVector<dim>() )
    { }

    //--------------------------------------------------------------------------
    //! Set the global ID
    void setID( const std::size_t id ) { id_ = id; }
    //! Set coordinates from iterator
    template<typename INPITER>
    void setX( INPITER iter )
    {
        for ( unsigned d = 0; d < dim; d ++ ) x_[d] = *iter++;
    }

    //--------------------------------------------------------------------------
    //! Return global ID of node
    std::size_t getID() const { return id_; }
    //! Pass coordinates to an iterator
    template<typename OUTITER>
    void getX( OUTITER iter ) const
    {
        for ( unsigned d = 0; d < dim; d ++ ) *iter++ = x_[d];
    }
    
private:
    std::size_t id_; //!< Global Node ID
    VecDim      x_;  //!< Coordinate of this node
};
 \end{lstlisting}
  \caption{Reduced version of the node class in \IS.}
  \label{fig:node}
\end{figure}


The design rationale of \IS{} is to separate data storage from
algorithms. In line with this idea is the concept to abstract finite
elements from the physical specifications. The main module of \IS{} is
the \texttt{base} module which contains all the data structures and
algorithms necessary for a finite element analysis without
specification of any physical model. On the other hand, the modules of
\texttt{heat}, \texttt{solid}, and \texttt{fluid} contain the integral
kernels as the they appear in the corresponding physical models of
heat conduction (or diffusion), elasticity and viscous fluid flow.

Next to the discussed modules, there are
\begin{description}
\item[\texttt{config}:] Configuration of the software with machine
  dependent setups
\item[\texttt{tools}:] A variety of tools used in the process of the
  finite element analysis: mesh-file conversion, post-processing
  tools, etc.
\item[\texttt{reference}:] Reference applications which address
  specific parts of the library and are (partially) tested.
\end{description}
In addition, there is the \texttt{sandbox} in which random
applications can be placed and maintained. Note that the entire
library and its applications are stored within the version management
system \texttt{Subversion} on a file server. A few of the implemented
finite element features of \IS{} are given in
table~\ref{tab:features}.
\begin{table}[bthp]
  \centering
  \begin{tabular}{lp{0.75\textwidth}}
	\toprule
    element shapes 
    &line (LINE), triangle (TRI), quadrilateral (QUAD), tetrahedron (TET),
    hexahedron (HEX)\\
    shape functions 
    &Lagrangian (linear and quadratic), B-Splines (any order)\\
    quadrature 
    &Gau\ss{}-Legendre (1- to 10-point rules), tensor-products
    for QUAD and HEX, Gau\ss{}-type quadrature for TRI and TET\\
    time integration
    &BDF and Adamas-Moulton up to fourth order \\
    solver
    &Cholesky, LU, Conjugate gradient (all via \texttt{Eigen3})\\
	\bottomrule
  \end{tabular}
  \caption{Some FEM features of \IS{}.}
  \label{tab:features}
\end{table}