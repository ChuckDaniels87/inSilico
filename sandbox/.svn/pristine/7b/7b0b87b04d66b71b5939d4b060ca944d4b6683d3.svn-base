#ifndef writevtk_h
#define writevtk_h

#include <string>
#include <vector>

#include <base/linearAlgebra.hpp>
#include <base/geometry.hpp>
#include <base/shape.hpp>
#include <base/cut/LevelSet.hpp>
#include <base/io/Format.hpp>
#include <base/io/vtk/LegacyWriter.hpp>
#include <base/io/smf/Writer.hpp>
#include <base/post/evaluateAtNodes.hpp>
#include <fluid/evaluations.hpp>

//------------------------------------------------------------------------------
//! Helper that converts the status of a DoF into a number
template<typename DOF>
struct DoFStatus
{
    static double apply( const DOF* doFPtr, const unsigned component )
    {
        if ( doFPtr -> isConstrained( component ) ) return 0.;
        if ( doFPtr -> isActive(      component ) ) return 1.;
        return -1.;
    }
};

//------------------------------------------------------------------------------
//! Write data to VTK
template<typename MESH, typename DISP, typename VELOC, typename PRESS>
void writeVTKFile( const std::string& baseName,
                   const unsigned step,
                   const MESH&    mesh,
                   const DISP&    displacement,
                   const VELOC&   velocity,
                   const PRESS&   pressure, 
                   const std::vector<base::cut::LevelSet<MESH::Node::dim> >& levelSet )
{
    // file name, open stream, generate writer
    const std::string vtkFile = baseName + "." + 
        base::io::leadingZeros( step ) + ".vtk";
    std::ofstream vtk( vtkFile.c_str() );
    base::io::vtk::LegacyWriter vtkWriter( vtk );

    // write grid
    vtkWriter.writeUnstructuredGrid( mesh );
    
    //--------------------------------------------------------------------------
    // level set data
    {
        std::vector<double> distances;
        std::transform( levelSet.begin(), levelSet.end(),
                        std::back_inserter( distances ),
                        boost::bind(
                            &base::cut::LevelSet<MESH::Node::dim>::getSignedDistance, _1 ) );

        vtkWriter.writePointData( distances.begin(), distances.end(), "distances" );

#ifdef VTKVERBOSE
        // closest points and in/out flag
        std::vector<typename MESH::Node::VecDim> closestPoints;
        std::vector<bool> location;
        std::transform( levelSet.begin(), levelSet.end(),
                        std::back_inserter( closestPoints ),
                        boost::bind( &base::cut::LevelSet<MESH::Node::dim>::getClosestPoint, _1 ) );
        std::transform( levelSet.begin(), levelSet.end(),
                        std::back_inserter( location ), 
                        boost::bind( &base::cut::LevelSet<MESH::Node::dim>::isInterior, _1 ) );
        vtkWriter.writePointData( closestPoints.begin(), closestPoints.end(), "cp" );
        vtkWriter.writePointData( location.begin(), location.end(), "inOut" );
#endif
    }

    //--------------------------------------------------------------------------
    // write solution data
    {
        base::io::vtk::writePointData( vtkWriter, mesh, displacement, "disp" );
        base::io::vtk::writePointData( vtkWriter, mesh, velocity,     "velocF" );
        base::io::vtk::writePointData( vtkWriter, mesh, pressure,     "press" );
    }

    //--------------------------------------------------------------------------
    // write previous displacement
    {
        typedef typename base::Vector<DISP::DegreeOfFreedom::size>::Type VecDof;
        std::vector<VecDof> nodalValues2;
        base::post::evaluateFieldHistoryAtNodes<1>( mesh, displacement, nodalValues2 );
        vtkWriter.writePointData( nodalValues2.begin(), nodalValues2.end(), "prevDisp" );
    }

#ifdef VTKVERBOSE
    //--------------------------------------------------------------------------
    // write the status of every DoF
    {
        static const unsigned size = DISP::DegreeOfFreedom::size;
        std::vector<typename base::Vector<size>::Type> doFStatusD, doFStatusU;
        std::vector<typename base::Vector<1>::Type   > doFStatusP;
        
        base::post::evaluateAtNodes(
            mesh, displacement,
            boost::bind( DoFStatus<typename DISP::DegreeOfFreedom>::apply, _1, _2 ),
            doFStatusD );

        base::post::evaluateAtNodes(
            mesh, velocity,
            boost::bind( DoFStatus<typename VELOC::DegreeOfFreedom>::apply, _1, _2 ),
            doFStatusU );

        base::post::evaluateAtNodes(
            mesh, pressure,
            boost::bind( DoFStatus<typename PRESS::DegreeOfFreedom>::apply, _1, _2 ),
            doFStatusP );
        
        vtkWriter.writePointData( doFStatusD.begin(), doFStatusD.end(), "statusD" );
        vtkWriter.writePointData( doFStatusP.begin(), doFStatusP.end(), "statusP" );
        vtkWriter.writePointData( doFStatusU.begin(), doFStatusU.end(), "statusU" );
    }
#endif

    vtk.close();
}


//------------------------------------------------------------------------------
//! Write the VTK file of surface mesh
template<typename SMESH,  typename DISP, typename VELOC, typename PRESS, typename MAT>
void writeSurfaceVTKFile( const std::string& name,
                          const unsigned num, 
                          const SMESH& immersedSurface,
                          const DISP&  displacement,
                          const MAT&   material,
                          const VELOC& velocity,
                          const PRESS& pressure,
                          const double viscosity )
{
    typedef typename SMESH::Node::VecDim VecDim;

    // filename, stream and generate writer
    const std::string vtkFile = name + "." + 
        base::io::leadingZeros( num ) + ".vtk";
    std::ofstream vtk( vtkFile.c_str() );
    base::io::vtk::LegacyWriter vtkWriter( vtk );

    // write the mesh
    vtkWriter.writeUnstructuredGrid( immersedSurface );

    //--------------------------------------------------------------------------
    // Evaluate displacement, velocity and pressure
    {
        // storage
        std::vector<VecDim> nodalD, nodalU;
        std::vector<double> nodalP;
        // go through all surface elements
        typename SMESH::ElementPtrConstIter eBegin = immersedSurface.elementsBegin();
        typename SMESH::ElementPtrConstIter eEnd   = immersedSurface.elementsEnd();
        for ( ; eBegin != eEnd; ++eBegin ) {
        
            typename SMESH::Element::DomainElement* geomEp =
                (*eBegin) -> getDomainElementPointer();
        
            const std::size_t elemID = geomEp -> getID();

            // get the field elements
            typename DISP::Element*  dispEp  = displacement.elementPtr( elemID );
            typename VELOC::Element* velocEp = velocity.elementPtr(     elemID );
            typename PRESS::Element* pressEp = pressure.elementPtr(     elemID );

            // go through the local coordinates of the surface element's nodes
            typename SMESH::Element::ParamIter   pIter = (*eBegin) -> parametricBegin();
            typename SMESH::Element::ParamIter   pEnd  = (*eBegin) -> parametricEnd();
            for ( ; pIter != pEnd; ++pIter ) {
                // evaluate and store
                nodalD.push_back( base::post::evaluateField( geomEp, dispEp,  *pIter ) );
                nodalU.push_back( base::post::evaluateField( geomEp, velocEp, *pIter ) );
                nodalP.push_back( base::post::evaluateField( geomEp, pressEp, *pIter )[0] );
            }
        }
        
        // pass on to writer
        vtkWriter.writePointData( nodalD.begin(), nodalD.end(), "Disp" );
        vtkWriter.writePointData( nodalU.begin(), nodalU.end(), "Veloc" );
        vtkWriter.writePointData( nodalP.begin(), nodalP.end(), "Press" );
    }
    
    //--------------------------------------------------------------------------
    // Compute normals and areas
    
    // storage
    std::vector<VecDim> normals;
    std::vector<double> areas;
    {
        // go through all surface elements
        typename SMESH::ElementPtrConstIter eBegin = immersedSurface.elementsBegin();
        typename SMESH::ElementPtrConstIter eEnd   = immersedSurface.elementsEnd();
        for ( ; eBegin != eEnd; ++eBegin ) {

            // compute normal the element centroid
            VecDim normal;
            const double area = 
                base::SurfaceNormal<typename SMESH::Element>()(
                    *eBegin,
                    base::ShapeCentroid<SMESH::Element::shape>::apply(),
                    normal );

            // store
            normals.push_back( normal );
            areas.push_back(   area );
        }

        vtkWriter.writeCellData( normals.begin(),   normals.end(),   "normals"  );

    }

    //--------------------------------------------------------------------------
    // Compute tractions from fluid and solid
    {
        // storages
        std::vector<typename SMESH::Node::VecDim> tractionsF, tractionsS;

        // bind surface to fluid fields
        typedef base::asmb::SurfaceFieldBinder<const SMESH,const VELOC, const PRESS> SFB1;
        SFB1 sfb1( immersedSurface, velocity, pressure );

        // bind surface to solid displacement
        typedef base::asmb::SurfaceFieldBinder<const SMESH,const DISP> SFB2;
        SFB2 sfb2( immersedSurface, displacement );

        // types of domain field tuples
        typedef typename SFB1::template TupleBinder<1,2>::Type STBUP;
        typedef typename base::asmb::DomainFieldElementPointerTuple<typename STBUP::Tuple>::Type
            DFTUP;
        
        typedef typename SFB2::template TupleBinder<1>::Type STBD;
        typedef typename base::asmb::DomainFieldElementPointerTuple<typename STBD::Tuple>::Type
            DFTD;

        // traction objects
        fluid::Traction<DFTUP> tractionF( viscosity );
        ::Traction<DFTD,MAT>   tractionS( material );

        // collect the sum of the forces (unused)
        VecDim sumF = base::constantVector<SMESH::Node::dim>( 0. );
        VecDim sumS = base::constantVector<SMESH::Node::dim>( 0. );

        // go through all surface element tuples
        typename SFB1::FieldIterator sEBegin1 = sfb1.elementsBegin();
        typename SFB2::FieldIterator sEBegin2 = sfb2.elementsBegin();
        typename SFB1::FieldIterator sEEnd    = sfb1.elementsEnd();
        for ( std::size_t ctr = 0; sEBegin1 != sEEnd; ++sEBegin1, ++sEBegin2, ctr++ ) {

            // get local domain coordinate of the centroid of the surface element
            const typename DFTUP::GeomElement::GeomFun::VecDim xi =
                (STBUP::makeTuple( *sEBegin1 ).geomElementPtr()) -> localDomainCoordinate( 
                    base::ShapeCentroid<SMESH::Element::shape>::apply() );

            // fluid domain element tuple
            const DFTUP dftf =
                base::asmb::DomainFieldElementPointerTuple<
                    typename STBUP::Tuple>::convert( *sEBegin1 );

            // compute fluid side traction and store
            const VecDim tf = tractionF( dftf, xi, normals[ ctr ] );
            tractionsF.push_back( tf );

            // solid domain element tuple
            const DFTD dftd =
                base::asmb::DomainFieldElementPointerTuple<
                    typename STBD::Tuple>::convert( *sEBegin2 );

            // compute solid side traction and store
            const VecDim ts = tractionS( dftd, xi, normals[ ctr ] );
            tractionsS.push_back( ts );

            // add to sum (like a mid-point rule integration)
            sumF += areas[ctr] * tf;
            sumS += areas[ctr] * ts;
        }
    
        vtkWriter.writeCellData( tractionsF.begin(), tractionsF.end(), "tractionF" );
        vtkWriter.writeCellData( tractionsS.begin(), tractionsS.end(), "tractionS" );
    }
    
    return;
}

#endif
