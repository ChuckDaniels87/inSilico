#define NITSCHE
#define DUAL
//#define STABIL

#include <string>
#include <boost/lexical_cast.hpp>

#include <base/verify.hpp>
#include <base/Unstructured.hpp>
#include <base/Field.hpp>
#include <base/mesh/Size.hpp>
#include <base/mesh/MeshBoundary.hpp>

#include <base/io/PropertiesParser.hpp>
#include <base/io/vtk/LegacyWriter.hpp>
#include <base/io/Format.hpp>
#include <base/io/smf/Writer.hpp>

#include <base/cut/Cell.hpp>
#include <base/cut/generateCutCells.hpp>
#include <base/cut/LevelSet.hpp>
#include <base/cut/analyticLevelSet.hpp>
#include <base/cut/bruteForce.hpp>
#include <base/cut/ComputeSupport.hpp>
#include <base/cut/Quadrature.hpp>
#include <base/cut/generateSurfaceMesh.hpp>

#include <base/cut/stabiliseBasis.hpp>
#include <base/cut/extractMeshFromCutCells.hpp>

#include <base/fe/Basis.hpp>

#include <base/dof/numbering.hpp>
#include <base/dof/generate.hpp>
#include <base/dof/Distribute.hpp>
#include <base/dof/location.hpp>
#include <base/dof/constrainBoundary.hpp>

#include <base/asmb/FieldBinder.hpp>
#include <base/asmb/SurfaceFieldBinder.hpp>
#include <base/asmb/StiffnessMatrix.hpp>
#include <base/asmb/NeumannForce.hpp>
#include <base/asmb/SimpleIntegrator.hpp>

#include <base/nitsche/Penalty.hpp>
#include <base/nitsche/Energy.hpp>
#include <base/nitsche/Parameters.hpp>

#include <base/solver/Eigen3.hpp>
#include <base/auxi/Memory.hpp>

#include <base/post/findLocation.hpp>
#include <base/post/Monitor.hpp>
#include <base/post/ParticleTracer.hpp>

#include "HyperElastic.hpp"
#include <mat/hypel/NeoHookeanCompressible.hpp>
#include <mat/Lame.hpp>

#include <fluid/Stokes.hpp>
#include <surf/Moments.hpp> 

#include "generateMesh.hpp"
#include "findLocation.hpp"

#include "extrapolateToOutside.hpp"
#include "advectField.hpp"
#include "moveSurface.hpp"

#include "writeVTK.hpp"

#include "Penalty.hpp"

#ifdef STABIL
#include "StiffnessMatrix2.hpp"
#include "../stokesStabil/Stabil.hpp"
#endif


const double coordTol = 1.e-4;

//------------------------------------------------------------------------------
enum BC
{
    SHEAR,
    SHEAR2,
    CAVITY,
    PIPE
};

std::ostream& operator <<(std::ostream &os, const BC& bc )
{
    switch( bc ) {
        case SHEAR:  os << "SHEAR"    ; break;
        case SHEAR2: os << "SHEAR2"   ; break;
        case CAVITY: os << "CAVITY"   ; break;
        case PIPE:   os << "PIPE"     ; break;
        default:     os << "UNDEFINED"; 
    }
    return os; 
} 

std::istream& operator >>(std::istream &is, BC& bc )
{
    std::string buffer;
    is >> buffer;
    if      ( buffer == "SHEAR" )  bc = SHEAR;
    else if ( buffer == "SHEAR2")  bc = SHEAR2;
    else if ( buffer == "CAVITY" ) bc = CAVITY;
    else if ( buffer == "PIPE"   ) bc = PIPE;
    else VERIFY_MSG( false, "Unknown BC found" );
    return is; 
} 


//------------------------------------------------------------------------------
// Analytic level set function for a spherical domain
template<unsigned DIM>
bool spherical( const typename base::Vector<DIM>::Type& x,
                typename base::Vector<DIM>::Type& xClosest,
                const double L )
{
    //xClosest[0] = L;
    if ( x.norm() < coordTol ) {
        xClosest = base::constantVector<DIM>(0.);
        xClosest[0] = L;
    }
    else{
        xClosest = (L / x.norm()) * x;
    }

    if ( x.norm() <= L ) return true;
    return false;
}


//------------------------------------------------------------------------------
template<unsigned DIM, typename DOF>
void shear( const typename base::Vector<DIM>::Type& x,
            DOF* doFPtr, const double factor, const double xmax ) 
{
    const bool top = ( std::abs( x[DIM-1] - xmax ) < coordTol );
    const bool bot = ( std::abs( x[DIM-1] + xmax ) < coordTol );

    if ( (not top) and (not bot) ) return;

    for ( unsigned d = 0; d < DIM; d++ ) {
        if ( doFPtr -> isActive(d) ) {
            const double value = ( d > 0 ? 0. : (top ? 1.0 : -1.0) );
            doFPtr -> constrainValue( d, value );
        }
    }
}

//------------------------------------------------------------------------------
template<unsigned DIM, typename DOF>
void shearOrtho( const typename base::Vector<DIM>::Type& x,
                 DOF* doFPtr, const double factor, const double xmax ) 
{
    VERIFY_MSG( DIM==3, "Only useful in 3D" );
    
    const bool top   = ( std::abs( x[2] - xmax ) < coordTol );
    const bool bot   = ( std::abs( x[2] + xmax ) < coordTol );

    const bool front = ( std::abs( x[1] - xmax ) < coordTol );
    const bool back  = ( std::abs( x[1] + xmax ) < coordTol );

    // on left and right boundaries (no condition)
    if ( (not top) and (not bot) and (not front) and (not back) ) return;
    

    for ( unsigned d = 0; d < DIM; d++ ) {
        if ( doFPtr -> isActive(d) ) {
             
            double value = 0.0;
            if (top   or bot ) value =  1.0;
            if (front or back) value = -1.0;

            // do not apply along edges
            if ( (top and front) or
                 (top and back ) or
                 (bot and front) or
                 (bot and back ) ) value = 0.;
            
            doFPtr -> constrainValue( d, value );
        }
    }
}

//------------------------------------------------------------------------------
// Function for the point-wise constraint of the Boundary
template<unsigned DIM, typename DOF>
void cavity( const typename base::Vector<DIM>::Type& x,
             DOF* doFPtr, const double factor, const double xmax ) 
{
    // if d-th coordinate has the value 1.0
    bool activeBdry = ( std::abs( x[DIM-1] - xmax ) < coordTol );
    // remove the corner/edge locations
    for ( unsigned d = 0; d < DIM-1; d ++ ) {
        if ( std::abs( x[d] + xmax ) < coordTol ) activeBdry = false;
        if ( std::abs( x[d] - xmax ) < coordTol ) activeBdry = false;
    }

    // boundary condition is either 0 or the e_1 vector 
    for ( unsigned d = 0; d < DIM; d ++ ) {
        const double value = ( (d==0) and activeBdry ) ? factor : 0.0;
        if ( doFPtr -> isActive(d) ) 
            doFPtr -> constrainValue( d, value );
    }

}

//------------------------------------------------------------------------------
// Function for the point-wise constraint of the Boundary
template<unsigned DIM, typename DOF>
void pipe( const typename base::Vector<DIM>::Type& x,
           DOF* doFPtr, const double factor, const double xmax ) 
{
    VERIFY_MSG( DIM==2, "3D Poiseuille flow not implemented" );

    // !! Hard-wired location of outflow boundary at x1=4;
    const bool isNeumann = (std::abs( x[0] - 4. ) < coordTol );
    if ( isNeumann ) return;
    
    const bool isInflow = ( std::abs( x[0] + xmax ) < coordTol );

    // boundary condition is either 0 or the e_1 vector 
    const double xi = x[1] / xmax;
    const double inflowU = 1.5 * factor * (1. - xi*xi);
    const double value = (isInflow ? inflowU : 0. );
    if ( doFPtr -> isActive(0) ) 
        doFPtr -> constrainValue( 0, value );
    for ( unsigned d = 1; d < DIM; d ++ ) {
        if ( doFPtr -> isActive(d) ) 
            doFPtr -> constrainValue( d, 0. );
    }
}

//------------------------------------------------------------------------------
template<unsigned DIM, typename DOF>
void dirichletBC( const typename base::Vector<DIM>::Type& x,
                  DOF* doFPtr, const double factor, const double xmax,
                  const BC& bc )
{
    if ( bc == SHEAR )
        return shear<DIM,DOF>( x, doFPtr, factor, xmax );
    else if ( bc == SHEAR2 )
        return shearOrtho<DIM,DOF>( x, doFPtr, factor, xmax );
    else if ( bc == CAVITY )
        return cavity<DIM,DOF>( x, doFPtr, factor, xmax );
    else if ( bc == PIPE )
        return pipe<DIM,DOF>( x, doFPtr, factor, xmax );
    else VERIFY_MSG( false, "Wrong BC identifier" );

    return;
}


//------------------------------------------------------------------------------
// Compute the enclosed volume, the centroid and principal directions
template<typename SUU, typename SURFFIELDBIND, typename SQUAD>
void surfaceFeatures( const SURFFIELDBIND& surfaceFieldBinder,
                      const SQUAD& surfaceQuadrature,
                      std::ostream& out )
{
    static const unsigned dim = SURFFIELDBIND::Mesh::Node::dim;
    typedef typename base::Vector<dim>::Type     VecDim;
    typedef typename base::Matrix<dim,dim>::Type MatDimDim;
    VecDim     centroid;
    MatDimDim inertia;

    // get shape features
    const double enclosed =
        surf::volumeCentroidAndInertia<SUU>( surfaceQuadrature, surfaceFieldBinder,
                                             centroid, inertia );

    // compute principal values of inertia and the angle-axis rotation
    MatDimDim evec;
    const VecDim princVal = base::eigenPairs( inertia, evec );
    const std::pair<double,base::Vector<3>::Type> aa = base::angleAxis( evec );
    
    out << enclosed << "  " << centroid.transpose() << "  "
        << princVal.transpose() << "  "
        << aa.first << "  "  << (aa.second).transpose();
}


//------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    const double initialMemory = base::auxi::memoryUsageInMegaBytes();

    
    typedef base::solver::Eigen3           Solver;

    
    // spatial dimension
    const unsigned    dim = 2; 
    
    if ( argc != 3 ) {
        std::cerr << "Usage: " << argv[0] << " N  input.dat\n"
                  << "(Compiled for dim=" << dim << ")\n\n";
        return -1;
    }
    
    // read name of input file
    const unsigned    numElements = boost::lexical_cast<unsigned>(    argv[1] );
    const std::string   inputFile = boost::lexical_cast<std::string>( argv[2] );

    // read from input file
    double xmax, L, E, nu, f, tolerance, viscosity, penaltyFacFluid, penaltyFacSolid, dt;
    double beta, findTolerance;
    unsigned numLoadSteps, maxIter;
    bool readMeshFromFile;
    BC   bc;
    std::string meshFile;
    {    
        //Feed properties parser with the variables to be read
        base::io::PropertiesParser prop;
        prop.registerPropertiesVar( "xmax",             xmax );
        prop.registerPropertiesVar( "L",                L );
        prop.registerPropertiesVar( "E",                E );
        prop.registerPropertiesVar( "nu",               nu );
        prop.registerPropertiesVar( "f",                f );
        prop.registerPropertiesVar( "numLoadSteps",     numLoadSteps );
        prop.registerPropertiesVar( "maxIter",          maxIter );
        prop.registerPropertiesVar( "tolerance",        tolerance );
        prop.registerPropertiesVar( "viscosity",        viscosity );
        prop.registerPropertiesVar( "penaltyFacFluid",  penaltyFacFluid );
        prop.registerPropertiesVar( "penaltyFacSolid",  penaltyFacSolid );
        prop.registerPropertiesVar( "dt",               dt );
        prop.registerPropertiesVar( "beta",             beta );
        prop.registerPropertiesVar( "findTolerance",    findTolerance );
        prop.registerPropertiesVar( "readMeshFromFile", readMeshFromFile );
        prop.registerPropertiesVar( "meshFile",         meshFile );
        prop.registerPropertiesVar( "bc",               bc );

        // Read variables from the input file
        std::ifstream inp( inputFile.c_str()  );
        VERIFY_MSG( inp.is_open(),                  "Cannot open input file" );
        VERIFY_MSG( prop.readValuesAndCheck( inp ), "Input error" );
        VERIFY_MSG( (beta>=0.) and (beta<=1.),      "beta is out of range" );
        inp.close( );
    }

    // basic attributes of the computation
    const unsigned             geomDeg  = 1;
#ifdef STABIL
    const unsigned            fieldDegU = 1;
#else
    const unsigned            fieldDegU = 2;
#endif
    const unsigned            fieldDegP = 1;
    const unsigned            fieldDegD = 1;
    const base::Shape             shape = base::HyperCubeShape<dim>::value;
    const unsigned    kernelDegEstimate = 5;
    const unsigned              doFSize = dim;
    const unsigned                nHist = 1;

    typedef base::Unstructured<shape,geomDeg>  Mesh;
    typedef Mesh::Node::VecDim VecDim;
    Mesh mesh;
    {
        if ( readMeshFromFile ) {
            std::ifstream smf( meshFile.c_str() );
            base::io::smf::readMesh( smf, mesh );
        }
        else {
            const double left = (dim == 1 ? 0. : -xmax );
            generateMesh( mesh, numElements, left, xmax );
        }
        //base::Vector<dim,unsigned>::Type  N;
        //N[0] = 3*numElements; N[1] = numElements;
        //VecDim a, b;
        //a[0] = -xmax;    a[1] = -xmax;
        //b[0] = 5.* xmax; b[1] =  xmax;
        //generateMesh<dim>( mesh, N, a, b );
    }

    // mesh size
    const double h = base::mesh::Size<Mesh::Element>::apply( mesh.elementPtr(0) );

    //--------------------------------------------------------------------------
    typedef base::cut::LevelSet<dim> LevelSet;
    std::vector<LevelSet> levelSet;
    base::cut::analyticLevelSet( mesh,
                                 boost::bind( &spherical<dim>, _1, _2, L ),
                                 true, levelSet );

    //--------------------------------------------------------------------------
    typedef base::cut::Cell<shape> Cell;
    std::vector<Cell> cells;
    base::cut::generateCutCells( mesh, levelSet, cells );

    //--------------------------------------------------------------------------
    // * FE Fields
    // Displacement
    typedef base::fe::Basis<shape,fieldDegD>             FEBasisD;
    typedef base::Field<FEBasisD,doFSize,nHist>          Displacement;
    Displacement displacement;
    base::dof::generate<FEBasisD>( mesh, displacement );

    typedef base::fe::Basis<shape,fieldDegU>         FEBasisU;
    typedef base::Field<FEBasisU,doFSize>            Velocity;
    typedef Velocity::DegreeOfFreedom                DoFU;
    Velocity velocity;
    base::dof::generate<FEBasisU>( mesh, velocity );
    
    typedef base::fe::Basis<shape,fieldDegP>         FEBasisP;
    typedef base::Field<FEBasisP,1>                  Pressure;
    Pressure pressure;
    base::dof::generate<FEBasisP>( mesh, pressure );


    // find geometry association for the dofs
    std::vector<std::pair<std::size_t,VecDim> > doFLocationD, doFLocationU;
    base::dof::associateLocation( displacement, doFLocationD );
    base::dof::associateLocation( velocity,     doFLocationU );

    // for domain field
    typedef base::asmb::FieldBinder<Mesh,Displacement,Velocity,Pressure> FieldBinder;
    FieldBinder fieldBinder( mesh, displacement, velocity, pressure );

    // Tuple binding: self-interaction
    typedef FieldBinder::TupleBinder<1,1>::Type DD;
    typedef FieldBinder::TupleBinder<2,2>::Type UU;
#ifdef STABIL
    typedef FieldBinder::TupleBinder<3,3>::Type PP;
#endif
    // Tuple binding: fluid-solid coupling
    typedef FieldBinder::TupleBinder<1,2>::Type DU;
    typedef FieldBinder::TupleBinder<2,1>::Type UD;
    typedef FieldBinder::TupleBinder<1,3>::Type DP;
    typedef FieldBinder::TupleBinder<3,1>::Type PD;
    // Tuple binding: fluid, internal coupling
    typedef FieldBinder::TupleBinder<2,3>::Type UP;
    typedef FieldBinder::TupleBinder<3,2>::Type PU;

    typedef base::cut::SurfaceMeshBinder<Mesh>::SurfaceMesh SurfaceMesh;
    typedef base::asmb::SurfaceFieldBinder<SurfaceMesh,Displacement,
                                           Velocity,Pressure> SurfaceFieldBinder;
    typedef SurfaceFieldBinder::TupleBinder<1,1>::Type SDD;
    typedef SurfaceFieldBinder::TupleBinder<2,2>::Type SUU;
    typedef SurfaceFieldBinder::TupleBinder<1,2>::Type SDU;
    typedef SurfaceFieldBinder::TupleBinder<2,1>::Type SUD;
    typedef SurfaceFieldBinder::TupleBinder<2,3>::Type SUP;
    typedef SurfaceFieldBinder::TupleBinder<1,3>::Type SDP;
    
    // Elastic material
    typedef mat::hypel::NeoHookeanCompressible Material;
    Material material( mat::Lame::lambda( E, nu), mat::Lame::mu( E, nu ) );

    // Elasticity kernel
    typedef ::HyperElastic<Material,DD::Tuple> HyperElastic;
    HyperElastic hyperElastic( material );
    typedef ::HyperElastic<Material,UD::Tuple> HyperElastic2;
    HyperElastic2 hyperElastic2( material );
    

    // Fluid kernel
    //typedef fluid::VectorLaplace<     UU::Tuple>  VecLaplace;
    //typedef fluid::VectorLaplace<     DU::Tuple>  VecLaplace2;
    typedef fluid::StressDivergence<  UU::Tuple>  VecLaplace;
    typedef fluid::StressDivergence<  DU::Tuple>  VecLaplace2;
    typedef fluid::PressureGradient<  UP::Tuple>  GradP;
    typedef fluid::PressureGradient<  DP::Tuple>  GradP2;
    typedef fluid::VelocityDivergence<PU::Tuple>  DivU;
    VecLaplace  vecLaplace(  viscosity );
    VecLaplace2 vecLaplace2( viscosity );
    GradP      gradP;
    GradP2     gradP2;
    DivU       divU; //(true); // change sign

    // Quadrature along a surface
    typedef base::SurfaceQuadrature<kernelDegEstimate,shape> SurfaceQuadrature;
    SurfaceQuadrature surfaceQuadrature;

    // Creates a list of <Element,faceNo> pairs
    base::mesh::MeshBoundary meshBoundary;
    meshBoundary.create( mesh.elementsBegin(), mesh.elementsEnd() );

    //--------------------------------------------------------------------------
    // * Loop over time steps *
    //--------------------------------------------------------------------------

    {
        std::cout << 0 << "  " << 0. << "  0  " << std::flush;

        // for surface field
        SurfaceMesh immersedSurface;
        base::cut::generateSurfaceMesh<Mesh,Cell>( mesh, cells, immersedSurface );
        
        SurfaceFieldBinder surfaceFieldBinder( immersedSurface, displacement,
                                               velocity, pressure );

        writeVTKFile( "euler", 0, 
                      mesh, displacement, velocity, pressure, levelSet );
        writeSurfaceVTKFile( "eulerSurf", 0, immersedSurface,
                             displacement, material, 
                             velocity, pressure, viscosity );

        surfaceFeatures<SUU>( surfaceFieldBinder, surfaceQuadrature, std::cout );
        std::cout << std::endl;
    }

    // register particles to be traced during the simulation
    base::post::ParticleTracer<dim> particleTracer;
    const std::string traces = "traces";
    {
        const boost::array<double,5> factors =
            {{ 0.5, 0.75, 0.9, 0.95, 0.975 }};
        
        for ( unsigned d = 0; d < dim; d++ ) {
            VecDim x = base::constantVector<dim>( 0. );
            for ( unsigned n = 0; n < factors.size(); n++ ) {
                x[d] = factors[n] * L;
                particleTracer.registerPoint( x );
            }
        }

        std::ofstream pt( traces.c_str() );
        particleTracer.writeLatest( pt );
    }


    double prevEnclosed;
    
    const double supportThreshold = std::numeric_limits<double>::min();
    for ( unsigned step = 0; step < numLoadSteps; step++ ) {

        std::cout << step+1 << "  " << (step+1) * dt << "  " << std::flush;

        // for surface field
        SurfaceMesh immersedSurface;
        base::cut::generateSurfaceMesh<Mesh,Cell>( mesh, cells, immersedSurface );
        
        SurfaceFieldBinder surfaceFieldBinder( immersedSurface, displacement,
                                               velocity, pressure );

        //----------------------------------------------------------------------
        // 0) Solve Lagrangian problem
        typedef base::cut::Quadrature<kernelDegEstimate,shape> CutQuadrature;
        CutQuadrature cutQuadratureSolid( cells, true  );
        CutQuadrature cutQuadratureFluid( cells, false );
        


        // compute supports
        std::vector<double> supportsD, supportsU, supportsP;
        base::cut::supportComputation( mesh, displacement, cutQuadratureSolid, supportsD );
        base::cut::supportComputation( mesh, velocity,     cutQuadratureFluid, supportsU );
        base::cut::supportComputation( mesh, pressure,     cutQuadratureFluid, supportsP );

        // Basis stabilisation
        {
            base::cut::stabiliseBasis( mesh, displacement, supportsD, doFLocationD );
            base::cut::stabiliseBasis( mesh, velocity,     supportsU, doFLocationU );
            base::cut::stabiliseBasis( mesh, pressure,     supportsP, doFLocationD );
        }
        
        // Hard-wired Dirichlet constraints (fluid BC)
        {
            const double diri = f;// * (step * dt);
            
            base::dof::constrainBoundary<FEBasisU>( meshBoundary.begin(),
                                                    meshBoundary.end(),
                                                    mesh, velocity,
                                                    boost::bind( &dirichletBC<dim,DoFU>, _1, _2,
                                                                 diri, xmax, bc ) );

            // Fix first pressure dof in case of closed cavity flow
            if ( bc == CAVITY ) {
                Pressure::DoFPtrIter pIter = pressure.doFsBegin();
                (*pIter) -> constrainValue( 0, 0.0 );
            }
        }
    
        // number DoFs 
        const std::size_t activeDoFsD = 
            base::dof::numberDoFsConsecutively( displacement.doFsBegin(), displacement.doFsEnd() );
        const std::size_t activeDoFsU = 
            base::dof::numberDoFsConsecutively( velocity.doFsBegin(), velocity.doFsEnd(),
                                                activeDoFsD );
        const std::size_t activeDoFsP = 
            base::dof::numberDoFsConsecutively( pressure.doFsBegin(), pressure.doFsEnd(),
                                                activeDoFsU + activeDoFsD );

        // start from 0 for the increments
        base::dof::clearDoFs( displacement );

        //----------------------------------------------------------------------
        // Nonlinear iterations
        unsigned iter = 0;
        for ( ; iter < maxIter; iter++ ) {

            // Create a solver object
            Solver solver( activeDoFsD + activeDoFsU + activeDoFsP );

            // register to solver
            {
                solver.registerFields<UU>( fieldBinder );
                solver.registerFields<DD>( fieldBinder );
            
                solver.registerFields<UP>( fieldBinder );
                solver.registerFields<PU>( fieldBinder );
            
                solver.registerFields<UD>( fieldBinder );
                solver.registerFields<DU>( fieldBinder );
            
                solver.registerFields<PD>( fieldBinder );
                solver.registerFields<DP>( fieldBinder );

#ifdef STABIL                
                solver.registerFields<PP>( fieldBinder );
#endif
            }



            // Internal forces in the solid
            base::asmb::computeResidualForces<DD>( cutQuadratureSolid, solver,
                                                   fieldBinder, hyperElastic );

            // Tangent matrix of the solid
            // (WW) constraint application not consistent yet
            base::asmb::stiffnessMatrixComputation<DD>( cutQuadratureSolid, solver,
                                                        fieldBinder, hyperElastic,
                                                        iter==0 );

            
            //
            const bool bla = false;
            // Stiffness matrices of the fluid
            base::asmb::stiffnessMatrixComputation<UU>( cutQuadratureFluid, solver,
                                                        fieldBinder, vecLaplace, bla );
            base::asmb::stiffnessMatrixComputation<UP>( cutQuadratureFluid, solver,
                                                        fieldBinder, gradP, bla );
            base::asmb::stiffnessMatrixComputation<PU>( cutQuadratureFluid, solver,
                                                        fieldBinder, divU, bla );

#ifdef STABIL
            typedef base::Quadrature<kernelDegEstimate,shape> Quadrature;
            Quadrature quadrature;
            Stabil1<PP::Tuple,Quadrature>  stabil1;
            base::asmb::stiffnessMatrixComputation2<PP>( quadrature, solver,
                                                         fieldBinder, stabil1, cells, bla );
            //cells );
#endif

            //------------------------------------------------------------------
            // Penalty terms for int_Gamma (dot(d) - u) (E delta d - mu delta u) ds
            {
                base::nitsche::OuterBoundary ps( penaltyFacSolid );

                // Solid - fluid
                base::nitsche::penaltyLHS<SDD>( surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                ps,  1.0 / dt );
                base::nitsche::penaltyLHS<SDU>( surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                ps, -1.0 );
                computePenaltyResidual<0,SDD>(  surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                ps, -1.0/dt );

                base::nitsche::OuterBoundary pf( penaltyFacFluid );
                
                // Fluid - solid
                base::nitsche::penaltyLHS<SUU>( surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                pf,  1.0 );
                base::nitsche::penaltyLHS<SUD>( surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                pf, -1.0 / dt );
                computePenaltyResidual<0,SUD>(  surfaceQuadrature, solver,
                                                surfaceFieldBinder,
                                                pf,  1.0 /dt );
            }
            
#ifdef NITSCHE
            //------------------------------------------------------------------
            // Boundary energy terms (beta = 0)  [ -int_Gamma (...) ds ]
            // Fluid - Mortar
            {
                const double virtPSign = 1.;
                const double alpha = 1. - beta;
                
                // +sigma^f(u,p) n dd
                base::nitsche::PrescribedParameters bla1( 1., alpha );
                base::nitsche::primalEnergyLHS<SDU>( vecLaplace2,   surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla1 );
                base::nitsche::primalEnergyLHS<SDP>( gradP2,        surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla1 );

                // -sigma^f(u,p) n du
                base::nitsche::PrescribedParameters bla2( 1., -alpha );
                base::nitsche::primalEnergyLHS<SUU>( vecLaplace,   surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla2 );
                base::nitsche::primalEnergyLHS<SUP>( gradP,        surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla2 );

#ifdef DUAL                
                // -sigma^f(du,pm dp) n (Delta d/Delta t)
                const double alpha2 = alpha;
                base::nitsche::PrescribedParameters bla3(  1., -alpha2/dt );
                base::nitsche::dualEnergyLHS<SDU>( vecLaplace2, surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla3 );
                base::nitsche::PrescribedParameters bla3p( 1., -alpha2/dt * virtPSign );
                base::nitsche::dualEnergyLHS<SDP>( gradP2,      surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla3p );
                
                // +sigma^f(du,pm dp) n u
                base::nitsche::PrescribedParameters bla4(  1., alpha2 );
                base::nitsche::dualEnergyLHS<SUU>( vecLaplace, surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla4 );
                base::nitsche::PrescribedParameters bla4p( 1., alpha2 * virtPSign );
                base::nitsche::dualEnergyLHS<SUP>( gradP,      surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla4p );
                
                // Residual: -sigma^f(du,pm dp) n (Delta d/Delta t)
                base::nitsche::PrescribedParameters bla5( 1., alpha2/dt );
                energyRHS2<SDU>( vecLaplace2, surfaceQuadrature, solver,
                                 surfaceFieldBinder, bla5 );
                base::nitsche::PrescribedParameters bla5p( 1., alpha2/dt * virtPSign );
                energyRHS2<SDP>( gradP2,      surfaceQuadrature, solver,
                                 surfaceFieldBinder, bla5p );

#endif                                               
            }

            // Solid - Mortar
            {
                // + (C^eff : Delta d) n dd
                base::nitsche::PrescribedParameters bla1( 1.,  beta );
                base::nitsche::primalEnergyLHS<SDD>( hyperElastic, surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla1 );
                
                // RHS terms: sigma(d) n dd
                base::nitsche::energyResidual<SDD>( hyperElastic, surfaceQuadrature, solver,
                                                    surfaceFieldBinder, bla1 );
                // - (C^eff : Delta d) n du
                base::nitsche::PrescribedParameters bla2( 1., -beta );
                base::nitsche::primalEnergyLHS<SUD>( hyperElastic2, surfaceQuadrature, solver,
                                                     surfaceFieldBinder, bla2 );
                
                // RHS terms: -sigma(d) n du
                base::nitsche::energyResidual<SUD>( hyperElastic2, surfaceQuadrature, solver,
                                                    surfaceFieldBinder, bla2 );

#ifdef DUAL
                // + (C^eff : dd) n (Delta d/Delta t)
                base::nitsche::PrescribedParameters bla3( 1.,  beta/dt );
                base::nitsche::dualEnergyLHS<SDD>( hyperElastic, surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla3 );
                energyRHS2<SDD>( hyperElastic, surfaceQuadrature, solver,
                                 surfaceFieldBinder, bla3 );
                
                //- (C^eff : dd) n u
                base::nitsche::PrescribedParameters bla4( 1., -beta );
                base::nitsche::dualEnergyLHS<SUD>( hyperElastic2, surfaceQuadrature, solver,
                                                   surfaceFieldBinder, bla4 );
#endif

            }
            
            
#endif
            double currentMem = base::auxi::memoryUsageInMegaBytes() - initialMemory;
            //std::cout << "\n* before finishAssembly() " << currentMem << std::endl;
            
            // Finalise assembly
            solver.finishAssembly();

            currentMem = base::auxi::memoryUsageInMegaBytes() - initialMemory;
            //std::cout << "\n* after finishAssembly() " << currentMem << std::endl;

            // norm of residual
            const double conv1 = solver.norm(0, activeDoFsD) / E;

            //std::cout << "* " << iter << " " << conv1 << "  " << std::flush;

            if ( isnan( conv1 ) ) return 1;
            
            if ( ( iter > 0 )  and ( conv1 < tolerance ) ) {
                //std::cout << std::endl;
                break;
            }

            // Solve
#ifdef LOAD_PARDISO
            solver.pardisoLUSolve();
#else

#ifdef LOAD_UMFPACK
            solver.umfPackLUSolve();
#else
            solver.superLUSolve();
            //solver.biCGStabSolve();
#endif
            
#endif
            
            // distribute results back to dofs
            base::dof::addToDoFsFromSolver( solver, displacement ); //<>
            base::dof::setDoFsFromSolver(   solver, velocity );
            base::dof::setDoFsFromSolver(   solver, pressure );

            const double conv2 = solver.norm(0, activeDoFsD);
            //std::cout << conv2 << std::endl;

            if ( conv2 < tolerance ) break;
            
        } // finish non-linear iteration
        std::cout << iter << "  " << std::flush;

        // write a vtk file
        writeVTKFile( "euler", step + 1, 
                      mesh, displacement, velocity, pressure, levelSet );
        writeSurfaceVTKFile( "eulerSurf", step + 1, immersedSurface,
                             displacement, material, 
                             velocity, pressure, viscosity );

        {
            particleTracer.update( mesh, displacement, findTolerance, 10 );
            std::ofstream pt( traces.c_str(), std::ios_base::app );
            particleTracer.writeLatest( pt );
        }


        // 1) Pass Data to complementary domain
        {
            //std::cout << "* Extrapolate" << std::endl;
            const double extL = h; // extrapolation length

            // pass extrapolated solution to inactive DoFs
            extrapolateToFictitious( mesh, displacement, extL, doFLocationD, levelSet );
        }
        
        // 2) Geometry update
        {
            //std::cout << "* New geometry" << std::endl;

            // rescaling
            //if ( step > 0 ) {
            //    // get shape features
            //    VecDim centroid;
            //    const double enclosed =
            //        surf::volumeAndCentroid<SDD>( surfaceQuadrature, surfaceFieldBinder, centroid );
            //
            //    const double factor = std::pow( prevEnclosed/enclosed,
            //                                    1./static_cast<double>( dim ) );
            //
            //    typename SurfaceMesh::NodePtrIter nIter = immersedSurface.nodesBegin();
            //    typename SurfaceMesh::NodePtrIter nEnd  = immersedSurface.nodesEnd(); 
            //    for ( ; nIter != nEnd; ++nIter ) {
            //        VecDim xOld;
            //        (*nIter) -> getX( &(xOld[0]) );
            //
            //        const VecDim xNew = centroid + factor * (xOld - centroid);
            //        (*nIter) -> setX( &(xNew[0]) );
            //    }
            //}

            // get shape features
            VecDim centroid;
            const double enclosed =
                surf::volumeAndCentroid<SDD>( surfaceQuadrature, surfaceFieldBinder, centroid );
            const double factor = ( step == 0 ? 1. : 
                                    std::pow( prevEnclosed/enclosed,
                                              1./static_cast<double>( dim ) ) );
            

            
            // Move with displacement solution
            moveSurface( mesh, displacement, immersedSurface, factor, centroid );

            // store the contained volume
            prevEnclosed =
                surf::enclosedVolume<SDD>( surfaceQuadrature, surfaceFieldBinder );


            base::cut::bruteForce( mesh, immersedSurface, true, levelSet );

            // update the cut cell structure
            base::cut::generateCutCells( mesh, levelSet, cells );

        }


        // 3) advect data
        {
            //std::cout << "* Advection" << std::endl;
            
            base::cut::supportComputation( mesh, displacement, cutQuadratureSolid, supportsD ); 
        
            // Find the location of the DoFs in the previous configuration
            std::vector<std::pair<std::size_t,VecDim> > previousDoFLocation;
            findPreviousDoFLocations( mesh, displacement, supportsD, 
                                      doFLocationD, previousDoFLocation,
                                      supportThreshold, findTolerance, 10 );
            
            // add previous solution to current solution: u_{n+1} = \Delta u + u_n
            {
                Displacement::DoFPtrIter dIter = displacement.doFsBegin();
                Displacement::DoFPtrIter dEnd  = displacement.doFsEnd();
                for ( ; dIter != dEnd; ++dIter ) {
                    for ( unsigned d = 0; d < dim; d++ ) {
                        const double prevU  = (*dIter) -> getHistoryValue<1>( d );
                        const double deltaU = (*dIter) -> getHistoryValue<0>( d );
                        const double currU = prevU + deltaU;
                        (*dIter) -> setValue( d, currU );
                    }
                }
            }
        
            // advect displacement field from previous to new location
            advectField( mesh, displacement, previousDoFLocation, supportsD, 
                         supportThreshold );
        
        }
        
        // push history
        base::dof::pushHistory( displacement );

        {
            // remove the linear constraints used in the stabilisation process
            base::dof::clearConstraints( displacement );
            base::dof::clearConstraints( velocity     );
            base::dof::clearConstraints( pressure     );
        }

        surfaceFeatures<SUU>( surfaceFieldBinder, surfaceQuadrature, std::cout );
        std::cout << std::endl;

    } // end load-steps

    return 0;
}
